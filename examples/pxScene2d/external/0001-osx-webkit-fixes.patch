From 180207868c7861fe85a4d0fa324ee87ae7c3c6d6 Mon Sep 17 00:00:00 2001
From: Admin <admin@Mac-Admin.local>
Date: Sat, 31 Aug 2019 15:04:24 +0300
Subject: [PATCH] 	osx webkit fixes

---
 Source/WTF/CMakeLists.txt                     |  2 +-
 Source/WebCore/html/HTMLMediaElement.cpp      | 47 ++++++++++++++---
 Source/WebCore/html/HTMLMediaElement.h        |  5 ++
 Source/WebCore/page/CaptionUserPreferences.h  |  2 +-
 Source/WebCore/page/Crypto.cpp                |  5 +-
 Source/WebCore/platform/graphics/FontCache.h  |  2 +-
 .../WebCore/platform/graphics/MediaPlayer.cpp |  6 +++
 .../WebCore/platform/graphics/MediaPlayer.h   |  5 ++
 .../gstreamer/MediaPlayerPrivateGStreamer.cpp |  8 +--
 .../MediaPlayerPrivateGStreamerBase.cpp       | 50 +++++++++++++++++++
 Source/cmake/OptionsGTK.cmake                 |  2 +-
 Tools/gtk/install-dependencies                |  8 +--
 12 files changed, 121 insertions(+), 21 deletions(-)

diff --git a/Source/WTF/CMakeLists.txt b/Source/WTF/CMakeLists.txt
index 7c615c5501c..d20608e9f48 100644
--- a/Source/WTF/CMakeLists.txt
+++ b/Source/WTF/CMakeLists.txt
@@ -7,5 +7,5 @@ add_subdirectory(wtf)
 # Apple builds have the ICU headers checked into ${WTF_DIR}/icu
 # Copy them into ${ICU_INCLUDE_DIRS} so the build behaves like find_package was used
 if (APPLE)
-    file(COPY ${WTF_DIR}/icu/unicode DESTINATION ${ICU_INCLUDE_DIRS})
+    #file(COPY ${WTF_DIR}/icu/unicode DESTINATION ${ICU_INCLUDE_DIRS})
 endif ()
diff --git a/Source/WebCore/html/HTMLMediaElement.cpp b/Source/WebCore/html/HTMLMediaElement.cpp
index 885cb54c59b..009fbd50316 100644
--- a/Source/WebCore/html/HTMLMediaElement.cpp
+++ b/Source/WebCore/html/HTMLMediaElement.cpp
@@ -470,6 +470,8 @@ HTMLMediaElement::HTMLMediaElement(const QualifiedName& tagName, Document& docum
     , m_logger(&document.logger())
     , m_logIdentifier(uniqueLogIdentifier())
 #endif
+    , m_renderFrameCallback(NULL)
+    , m_renderFrameCallbackArg(NULL)
 {
     allMediaElements().add(this);
 
@@ -1171,6 +1173,15 @@ double HTMLMediaElement::getStartDate() const
     return m_player->getStartDate().toDouble();
 }
 
+void HTMLMediaElement::setRenderFrameCallback(void (*cb)(void *, void*), void* arg)
+{
+    m_renderFrameCallback = cb;
+    m_renderFrameCallbackArg = arg;
+    if (m_player) {
+        m_player->setRenderFrameCallback(m_renderFrameCallback, m_renderFrameCallbackArg);
+    }
+}
+
 void HTMLMediaElement::load()
 {
     Ref<HTMLMediaElement> protectedThis(*this); // prepareForLoad may result in a 'beforeload' event, which can make arbitrary DOM mutations.
@@ -1214,11 +1225,15 @@ void HTMLMediaElement::prepareForLoad()
     m_loadState = WaitingForSource;
     m_currentSourceNode = nullptr;
 
-    if (!document().hasBrowsingContext())
-        return;
+    //if (!document().hasBrowsingContext())
+        //return;
 
     createMediaPlayer();
 
+    if (m_player) {
+        m_player->setRenderFrameCallback(m_renderFrameCallback, m_renderFrameCallbackArg);
+    }
+
     // 2 - Let pending tasks be a list of all tasks from the media element's media element event task source in one of the task queues.
     // 3 - For each task in pending tasks that would resolve pending play promises or reject pending play promises, immediately resolve or reject those promises in the order the corresponding tasks were queued.
     // 4 - Remove each task in pending tasks from its task queue
@@ -1499,6 +1514,7 @@ void HTMLMediaElement::loadResource(const URL& initialURL, ContentType& contentT
 
     INFO_LOG(LOGIDENTIFIER, initialURL, contentType, keySystem);
 
+    /*
     RefPtr<Frame> frame = document().frame();
     if (!frame) {
         mediaLoadingFailed(MediaPlayer::FormatError);
@@ -1510,8 +1526,10 @@ void HTMLMediaElement::loadResource(const URL& initialURL, ContentType& contentT
         mediaLoadingFailed(MediaPlayer::FormatError);
         return;
     }
+    */
 
-    URL url = initialURL;
+    URL url = URL(URL(), "blob:null/71b969b0-131e-4f2d-b53b-742bb78aabc0"); // initialURL;
+    /*
     if (!url.isEmpty() && !frame->loader().willLoadMediaElementURL(url, *this)) {
         mediaLoadingFailed(MediaPlayer::FormatError);
         return;
@@ -1525,12 +1543,14 @@ void HTMLMediaElement::loadResource(const URL& initialURL, ContentType& contentT
         }
     }
 #endif
+*/
 
     // The resource fetch algorithm
     m_networkState = NETWORK_LOADING;
 
     // If the URL should be loaded from the application cache, pass the URL of the cached file to the media engine.
     ApplicationCacheResource* resource = nullptr;
+    /*
     if (!url.isEmpty() && frame->loader().documentLoader()->applicationCacheHost().shouldLoadResourceFromApplicationCache(ResourceRequest(url), resource)) {
         // Resources that are not present in the manifest will always fail to load (at least, after the
         // cache has been primed the first time), making the testing of offline applications simpler.
@@ -1539,9 +1559,10 @@ void HTMLMediaElement::loadResource(const URL& initialURL, ContentType& contentT
             return;
         }
     }
+    */
 
     // Log that we started loading a media element.
-    page->diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::loadingKey(), ShouldSample::No);
+    //page->diagnosticLoggingClient().logDiagnosticMessage(isVideo() ? DiagnosticLoggingKeys::videoKey() : DiagnosticLoggingKeys::audioKey(), DiagnosticLoggingKeys::loadingKey(), ShouldSample::No);
 
     m_firstTimePlaying = true;
 
@@ -1558,8 +1579,8 @@ void HTMLMediaElement::loadResource(const URL& initialURL, ContentType& contentT
 
     startProgressEventTimer();
 
-    bool privateMode = document().page() && document().page()->usesEphemeralSession();
-    m_player->setPrivateBrowsingMode(privateMode);
+    //bool privateMode = document().page() && document().page()->usesEphemeralSession();
+    //m_player->setPrivateBrowsingMode(privateMode);
 
     // Reset display mode to force a recalculation of what to show because we are resetting the player.
     setDisplayMode(Unknown);
@@ -3500,6 +3521,7 @@ void HTMLMediaElement::play(DOMPromiseDeferred<void>&& promise)
 {
     ALWAYS_LOG(LOGIDENTIFIER);
 
+    /*
     auto success = m_mediaSession->playbackPermitted();
     if (!success) {
         if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
@@ -3507,6 +3529,7 @@ void HTMLMediaElement::play(DOMPromiseDeferred<void>&& promise)
         promise.reject(NotAllowedError);
         return;
     }
+    */
 
     if (m_error && m_error->code() == MediaError::MEDIA_ERR_SRC_NOT_SUPPORTED) {
         promise.reject(NotSupportedError, "The operation is not supported.");
@@ -3524,6 +3547,7 @@ void HTMLMediaElement::play()
 {
     ALWAYS_LOG(LOGIDENTIFIER);
 
+    /*
     auto success = m_mediaSession->playbackPermitted();
     if (!success) {
         if (success.value() == MediaPlaybackDenialReason::UserGestureRequired)
@@ -3532,6 +3556,7 @@ void HTMLMediaElement::play()
     }
     if (processingUserGestureForMedia())
         removeBehaviorRestrictionsAfterFirstUserGesture();
+        */
 
     playInternal();
 }
@@ -3545,10 +3570,12 @@ void HTMLMediaElement::playInternal()
         return;
     }
 
+    /*
     if (!document().hasBrowsingContext()) {
         INFO_LOG(LOGIDENTIFIER, "returning because there is no browsing context");
         return;
     }
+    */
 
     if (!m_mediaSession->clientWillBeginPlayback()) {
         ALWAYS_LOG(LOGIDENTIFIER, "returning because of interruption");
@@ -3628,8 +3655,10 @@ void HTMLMediaElement::pause()
     if (m_waitingToEnterFullscreen)
         m_waitingToEnterFullscreen = false;
 
+    /*
     if (!m_mediaSession->playbackPermitted())
         return;
+        */
 
     if (processingUserGestureForMedia())
         removeBehaviorRestrictionsAfterFirstUserGesture(MediaElementSession::RequireUserGestureToControlControlsManager);
@@ -3642,6 +3671,7 @@ void HTMLMediaElement::pauseInternal()
 {
     ALWAYS_LOG(LOGIDENTIFIER);
 
+    /*
     if (isSuspended()) {
         ALWAYS_LOG(LOGIDENTIFIER, "returning because context is suspended");
         return;
@@ -3656,13 +3686,14 @@ void HTMLMediaElement::pauseInternal()
         ALWAYS_LOG(LOGIDENTIFIER, "returning because of interruption");
         return;
     }
+    */
 
     // 4.8.10.9. Playing the media resource
     if (!m_player || m_networkState == NETWORK_EMPTY) {
         // Unless the restriction on media requiring user action has been lifted
         // don't trigger loading if a script calls pause().
-        if (!m_mediaSession->playbackPermitted())
-            return;
+        //if (!m_mediaSession->playbackPermitted())
+            //return;
         selectMediaResource();
     }
 
diff --git a/Source/WebCore/html/HTMLMediaElement.h b/Source/WebCore/html/HTMLMediaElement.h
index d0bab9fc9d6..bc0dee53bfc 100644
--- a/Source/WebCore/html/HTMLMediaElement.h
+++ b/Source/WebCore/html/HTMLMediaElement.h
@@ -176,6 +176,11 @@ public:
 
     bool doesHaveAttribute(const AtomString&, AtomString* value = nullptr) const override;
 
+    void setRenderFrameCallback(void (*cb)(void*, void*), void* arg);
+
+    void (*m_renderFrameCallback)(void*, void*);
+    void *m_renderFrameCallbackArg;
+
     PlatformLayer* platformLayer() const;
     bool isVideoLayerInline();
     void setPreparedToReturnVideoLayerToInline(bool);
diff --git a/Source/WebCore/page/CaptionUserPreferences.h b/Source/WebCore/page/CaptionUserPreferences.h
index e6adb67da94..8acb6ecaf22 100644
--- a/Source/WebCore/page/CaptionUserPreferences.h
+++ b/Source/WebCore/page/CaptionUserPreferences.h
@@ -94,7 +94,7 @@ public:
     String primaryAudioTrackLanguageOverride() const;
 
     virtual bool testingMode() const { return m_testingMode; }
-    void setTestingMode(bool override) { m_testingMode = override; }
+    void setTestingMode(bool val) { m_testingMode = val; }
     
     PageGroup& pageGroup() const { return m_pageGroup; }
 
diff --git a/Source/WebCore/page/Crypto.cpp b/Source/WebCore/page/Crypto.cpp
index 69c36e971b7..d9f9ad04891 100644
--- a/Source/WebCore/page/Crypto.cpp
+++ b/Source/WebCore/page/Crypto.cpp
@@ -59,8 +59,9 @@ ExceptionOr<void> Crypto::getRandomValues(ArrayBufferView& array)
     if (array.byteLength() > 65536)
         return Exception { QuotaExceededError };
 #if OS(DARWIN)
-    auto rc = CCRandomGenerateBytes(array.baseAddress(), array.byteLength());
-    RELEASE_ASSERT(rc == kCCSuccess);
+    //auto rc = CCRandomGenerateBytes(array.baseAddress(), array.byteLength());
+    //RELEASE_ASSERT(rc == kCCSuccess);
+    cryptographicallyRandomValues(array.baseAddress(), array.byteLength());
 #else
     cryptographicallyRandomValues(array.baseAddress(), array.byteLength());
 #endif
diff --git a/Source/WebCore/platform/graphics/FontCache.h b/Source/WebCore/platform/graphics/FontCache.h
index 0a3a33f93b1..2e9ef7fbf18 100644
--- a/Source/WebCore/platform/graphics/FontCache.h
+++ b/Source/WebCore/platform/graphics/FontCache.h
@@ -32,7 +32,7 @@
 #include "FontDescription.h"
 #include "FontPlatformData.h"
 #include "FontTaggedSettings.h"
-#include "Timer.h"
+#include "platform/Timer.h"
 #include <array>
 #include <limits.h>
 #include <wtf/Forward.h>
diff --git a/Source/WebCore/platform/graphics/MediaPlayer.cpp b/Source/WebCore/platform/graphics/MediaPlayer.cpp
index 757f09567dc..a0361091c22 100644
--- a/Source/WebCore/platform/graphics/MediaPlayer.cpp
+++ b/Source/WebCore/platform/graphics/MediaPlayer.cpp
@@ -364,6 +364,12 @@ MediaPlayer::~MediaPlayer()
     ASSERT(!m_initializingMediaEngine);
 }
 
+void MediaPlayer::setRenderFrameCallback(void (*cb)(void*, void*), void* arg)
+{
+    m_renderFrameCallback = cb;
+    m_renderFrameCallbackArg = arg;
+}
+
 void MediaPlayer::invalidate()
 {
     m_client = &nullMediaPlayerClient();
diff --git a/Source/WebCore/platform/graphics/MediaPlayer.h b/Source/WebCore/platform/graphics/MediaPlayer.h
index e9df9458787..305cbb87ea6 100644
--- a/Source/WebCore/platform/graphics/MediaPlayer.h
+++ b/Source/WebCore/platform/graphics/MediaPlayer.h
@@ -270,6 +270,11 @@ public:
     bool doesHaveAttribute(const AtomString&, AtomString* value = nullptr) const;
     PlatformLayer* platformLayer() const;
 
+    void setRenderFrameCallback(void (*cb)(void*, void*), void* arg);
+
+    void (*m_renderFrameCallback)(void*, void*) = nullptr;
+    void *m_renderFrameCallbackArg = nullptr;
+
 #if PLATFORM(IOS_FAMILY) || (PLATFORM(MAC) && ENABLE(VIDEO_PRESENTATION_MODE))
     void setVideoFullscreenLayer(PlatformLayer*, WTF::Function<void()>&& completionHandler = [] { });
     void setVideoFullscreenFrame(FloatRect);
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
index 6d7105e9a1a..30b5e0ad93e 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
@@ -494,7 +494,7 @@ MediaTime MediaPlayerPrivateGStreamer::platformDuration() const
         return MediaTime::invalidTime();
 
     int64_t duration = 0;
-    if (!gst_element_query_duration(m_pipeline.get(), GST_FORMAT_TIME, &duration) || !GST_CLOCK_TIME_IS_VALID(duration)) {
+    if (!gst_element_query_duration(m_pipeline.get(), GST_FORMAT_TIME, (gint64*)&duration) || !GST_CLOCK_TIME_IS_VALID(duration)) {
         GST_DEBUG_OBJECT(pipeline(), "Time duration query failed for %s", m_url.string().utf8().data());
         return MediaTime::positiveInfiniteTime();
     }
@@ -1373,7 +1373,7 @@ void MediaPlayerPrivateGStreamer::handleMessage(GstMessage* message)
             if (gst_structure_get(structure, "response-headers", GST_TYPE_STRUCTURE, &responseHeaders.outPtr(), nullptr)) {
                 const char* contentLengthHeaderName = httpHeaderNameString(HTTPHeaderName::ContentLength).utf8().data();
                 uint64_t contentLength = 0;
-                if (!gst_structure_get_uint64(responseHeaders.get(), contentLengthHeaderName, &contentLength)) {
+                if (!gst_structure_get_uint64(responseHeaders.get(), contentLengthHeaderName, (guint64*)&contentLength)) {
                     // souphttpsrc sets a string for Content-Length, so
                     // handle it here, until we remove the webkit+ protocol
                     // prefix from webkitwebsrc.
@@ -2468,7 +2468,9 @@ void MediaPlayerPrivateGStreamer::createGSTPlayBin(const URL& url, const String&
     g_object_set(m_pipeline.get(), "text-sink", m_textAppSink.get(), nullptr);
 #endif
 
-    g_object_set(m_pipeline.get(), "video-sink", createVideoSink(), "audio-sink", createAudioSink(), nullptr);
+    g_object_set(m_pipeline.get(), "video-sink", createVideoSink(), nullptr); //"audio-sink", createAudioSink(), nullptr);
+    //GstElement* videoSink = gst_element_factory_make("glimagesink", "glimagesink");
+    //g_object_set (m_pipeline.get(), "video-sink", videoSink, NULL);
 
     configurePlaySink();
 
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.cpp
index 91e17899582..160283ade13 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamerBase.cpp
@@ -1020,9 +1020,36 @@ MediaPlayer::MovieLoadType MediaPlayerPrivateGStreamerBase::movieLoadType() cons
     return MediaPlayer::Download;
 }
 
+static gboolean
+GStreamer_DrawCallback(GstElement* /*gl_sink*/, void* /*context*/, GstSample *sample, MediaPlayerPrivateGStreamerBase *arg)
+{
+    MediaPlayer *mediaPlayer = arg->mediaPlayer();
+    if (mediaPlayer && mediaPlayer->m_renderFrameCallback) {
+        (mediaPlayer->m_renderFrameCallback)(mediaPlayer->m_renderFrameCallbackArg, (void*)sample);
+    }
+    return TRUE;
+}
+
 #if USE(GSTREAMER_GL)
 GstElement* MediaPlayerPrivateGStreamerBase::createGLAppSink()
 {
+#if 0
+    GstElement* appsink = gst_element_factory_make("filesink", "webkit-gl-video-sink");
+    if (!appsink)
+        return nullptr;
+    g_object_set(appsink, "location", "/mnt/ssd/out.raw", nullptr);
+    return appsink;
+#endif
+    
+#if 1
+    GstElement* appsink = gst_element_factory_make("glimagesink", "webkit-gl-video-sink");
+    if (!appsink)
+        return nullptr;
+    g_signal_connect(G_OBJECT(appsink), "client-draw", G_CALLBACK(GStreamer_DrawCallback), this);
+    return appsink;
+#endif
+
+#if 0
     GstElement* appsink = gst_element_factory_make("appsink", "webkit-gl-video-sink");
     if (!appsink)
         return nullptr;
@@ -1055,10 +1082,31 @@ GstElement* MediaPlayerPrivateGStreamerBase::createGLAppSink()
     }, this, nullptr);
 
     return appsink;
+#endif
 }
 
 GstElement* MediaPlayerPrivateGStreamerBase::createVideoSinkGL()
 {
+#if 0
+    GstElement* bin = gst_bin_new ("video_sink_bin");
+    GstElement* jpegenc = gst_element_factory_make ("jpegenc", NULL);
+    GstElement* avimux = gst_element_factory_make ("avimux", NULL);
+    GstElement* filesink = gst_element_factory_make ("filesink", NULL);
+    g_object_set (filesink, "location", "mjpeg.avi", NULL);
+    gst_bin_add_many(GST_BIN(bin), jpegenc, avimux, filesink, NULL);
+    gst_element_link_many(jpegenc, avimux, filesink, NULL);
+    GstPad *pad = gst_element_get_static_pad (jpegenc, "sink");
+    GstPad *ghost_pad = gst_ghost_pad_new ("sink", pad);
+    gst_pad_set_active (ghost_pad, TRUE);
+    gst_element_add_pad (bin, ghost_pad);
+    gst_object_unref (pad);
+    return bin;
+#endif
+
+    //GstElement* filesink = gst_element_factory_make ("glimagesink", NULL);
+    //return filesink;
+
+#if 1
     gboolean result = TRUE;
     GstElement* videoSink = gst_bin_new(nullptr);
     GstElement* upload = gst_element_factory_make("glupload", nullptr);
@@ -1096,6 +1144,8 @@ GstElement* MediaPlayerPrivateGStreamerBase::createVideoSinkGL()
         videoSink = nullptr;
     }
     return videoSink;
+#endif
+
 }
 
 void MediaPlayerPrivateGStreamerBase::ensureGLVideoSinkContext()
diff --git a/Source/cmake/OptionsGTK.cmake b/Source/cmake/OptionsGTK.cmake
index 1f36ab4c577..fef9b4cd4c0 100644
--- a/Source/cmake/OptionsGTK.cmake
+++ b/Source/cmake/OptionsGTK.cmake
@@ -82,7 +82,7 @@ WEBKIT_OPTION_DEFINE(ENABLE_QUARTZ_TARGET "Whether to enable support for the Qua
 WEBKIT_OPTION_DEFINE(ENABLE_X11_TARGET "Whether to enable support for the X11 windowing target." PUBLIC ${GTK3_SUPPORTS_X11})
 WEBKIT_OPTION_DEFINE(ENABLE_WAYLAND_TARGET "Whether to enable support for the Wayland windowing target." PUBLIC ${GTK3_SUPPORTS_WAYLAND})
 WEBKIT_OPTION_DEFINE(USE_LIBNOTIFY "Whether to enable the default web notification implementation." PUBLIC ON)
-WEBKIT_OPTION_DEFINE(USE_LIBHYPHEN "Whether to enable the default automatic hyphenation implementation." PUBLIC ON)
+WEBKIT_OPTION_DEFINE(USE_LIBHYPHEN "Whether to enable the default automatic hyphenation implementation." PUBLIC OFF)
 WEBKIT_OPTION_DEFINE(USE_LIBSECRET "Whether to enable the persistent credential storage using libsecret." PUBLIC ON)
 WEBKIT_OPTION_DEFINE(USE_OPENJPEG "Whether to enable support for JPEG2000 images." PUBLIC ON)
 WEBKIT_OPTION_DEFINE(USE_WOFF2 "Whether to enable support for WOFF2 Web Fonts." PUBLIC ON)
diff --git a/Tools/gtk/install-dependencies b/Tools/gtk/install-dependencies
index 3d180fc2431..98ac54d654c 100755
--- a/Tools/gtk/install-dependencies
+++ b/Tools/gtk/install-dependencies
@@ -1,10 +1,10 @@
 #!/usr/bin/env bash
 
 # This script needs to be run with root rights.
-if [ $UID -ne 0 ]; then
-    sudo $0
-    exit 0
-fi
+#if [ $UID -ne 0 ]; then
+#    sudo $0
+#    exit 0
+#fi
 
 function printNotSupportedMessageAndExit() {
     echo
-- 
2.20.1 (Apple Git-117)

