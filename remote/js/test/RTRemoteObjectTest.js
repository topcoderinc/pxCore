/*

pxCore Copyright 2005-2018 John Robinson

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.

*/

/**
 * Unit tests for RTRemoteObjectTest
 *
 * @author      TCSCODER
 * @version     1.0
 */

const RTRemoteMulticastResolver = require('../lib/RTRemoteMulticastResolver');
const RTRemoteConnectionManager = require('../lib/RTRemoteConnectionManager');
const RTRemoteServer = require('../lib/RTRemoteServer');
const RTValueHelper = require('../lib/RTValueHelper');
const RTValueType = require('../lib/RTValueType');
const SampleObject = require('./common/SampleObject');
const RTConst = require('../lib/RTConst');
const logger = require('../lib/common/logger');
const helper = require('../lib/common/helper');
const BigNumber = require('bignumber.js');

const should = require('should'); // eslint-disable-line no-unused-vars

// RTRemoteMulticastResolver instance
const resolve = new RTRemoteMulticastResolver('224.10.10.12', 10021);

let rtObject;

/*
 * Test RTRemoteObject
 */

describe('RTRemoteObject', () => {
  before((done) => {
  // Server is explicitly required to test all functions of RTObject
    RTRemoteServer.create('224.10.10.12', 10021, '127.0.0.1').then((rtRemoteServer) => {
      Promise.resolve()
        .then(() => rtRemoteServer.registerObject('1_object', new SampleObject()))
        .then(() => resolve.start())
        .then(() => {
          resolve.locateObject('1_object') // find remote object
            .then(uri => RTRemoteConnectionManager.getObjectProxy(uri)) // crate remote object
            .then((rtObj) => {
              rtObject = rtObj;
              done();
            });
        });
    });
  });

  describe('Testing set and get function ', () => {
    it('Setting and Getting value via Name should succeed', (done) => {
      Promise.resolve()
      // Test Float
        .then(() => doBasicTest(rtObject, RTValueType.FLOAT, 1.23456789, 'ffloat').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.FLOAT, -1.234567, 'ffloat').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.FLOAT, 12.34567, 'ffloat').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.FLOAT, 123.4567, 'ffloat').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.FLOAT, 1234.567, 'ffloat').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.FLOAT, 123456.71, 'ffloat').then((status) => {
          status.should.be.eql(true);
        }))
      // test boolean
        .then(() => doBasicTest(rtObject, RTValueType.BOOLEAN, true, 'bbool').then((status) => {
          status.should.be.eql(true);
        }))

      // BUG: Server getting timed out exactly after 7 tests
        .then(() => doBasicTest(rtObject, RTValueType.BOOLEAN, false, 'bbool').then((status) => {
          status.should.be.eql(true);
        }))

      // test int8, the data range is [-128,127]
        .then(() => doBasicTest(rtObject, RTValueType.INT8, -128, 'int8').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.INT8, 0, 'int8').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.INT8, 127, 'int8').then((status) => {
          status.should.be.eql(true);
        }))
      // test uint8, the data range is [0,255]
        .then(() => doBasicTest(rtObject, RTValueType.UINT8, 0, 'uint8').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.UINT8, 255, 'uint8').then((status) => {
          status.should.be.eql(true);
        }))
      // test int32, range is  [–2147483648 , 2147483647]
        .then(() => doBasicTest(rtObject, RTValueType.INT32, -2147483648, 'int32').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.INT32, 0, 'int32').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.INT32, 123, 'int32').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.INT32, 2147483647, 'int32').then((status) => {
          status.should.be.eql(true);
        }))
      // test uint32, range is [0 - 4,294,967,295]
        .then(() => doBasicTest(rtObject, RTValueType.UINT32, 0, 'uint32').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.UINT32, 4294967295, 'uint32').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.UINT32, 123123, 'uint32').then((status) => {
          status.should.be.eql(true);
        }))
      // test int64, range is [–9223372036854775808  9223372036854775807]
        .then(() => doBasicTest(rtObject, RTValueType.INT64, new BigNumber('-9223372036854775808'), 'int64').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.INT64, new BigNumber('9223372036854775807'), 'int64').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.INT64, new BigNumber(0), 'int64').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.INT64, new BigNumber(123123), 'int64').then((status) => {
          status.should.be.eql(true);
        }))
      // test uint64, range is [0 - 18446744073709551615]
        .then(() => doBasicTest(rtObject, RTValueType.UINT64, new BigNumber('18446744073709551615'), 'uint64').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.UINT64, new BigNumber(0), 'uint64').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.UINT64, new BigNumber(123123123), 'uint64').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.UINT64, new BigNumber('123'), 'uint64').then((status) => {
          status.should.be.eql(true);
        }))
      // test Double
        .then(() => doBasicTest(rtObject, RTValueType.DOUBLE, 1231.12312312312, 'ddouble').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.DOUBLE, -1231.12312312312, 'ddouble').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.DOUBLE, -0.12, 'ddouble').then((status) => {
          status.should.be.eql(true);
        }))
      // Testing string
        .then(() => doBasicTest(
          rtObject, RTValueType.STRING,
          'implemented in both /Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Conten', 'string',
        ).then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(
          rtObject, RTValueType.STRING,
          '{"jsonKey":"values"}', 'string',
        ).then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.STRING, '1', 'string').then((status) => {
          status.should.be.eql(true);
        }))
      // void ptr is a uint32 or uint64
        .then(() => doBasicTest(rtObject, RTValueType.VOIDPTR, new BigNumber('723123231'), 'vptr').then((status) => {
          status.should.be.eql(true);
        }))

        .then(() => doBasicTest(rtObject, RTValueType.VOIDPTR, new BigNumber('789892349'), 'vptr').then((status) => {
          status.should.be.eql(true);
          done();
        }))
        .catch(err => logger.error(err));
    });

    it('Setting and Getting value in array item by index 0', (done) => {
      rtObject.get('arr') // get array object first
        .then(arrValue => arrValue.value.set(0, RTValueHelper.create(12, RTValueType.INT32)).then(() => arrValue))
        .then(arrValue => arrValue.value.get(0).then((rtValue) => {
          rtValue.type.should.be.eql(RTValueType.INT32);
          rtValue.value.should.be.eql(12);
          done();
        }));
    });

    it('Setting and Getting value in array item by index 1', (done) => {
      rtObject.get('arr') // get array object first
        .then(arrValue => arrValue.value.set(1, RTValueHelper.create(12.34, RTValueType.FLOAT)).then(() => arrValue))
        .then(arrValue => arrValue.value.get(1).then((rtValue) => {
          rtValue.type.should.be.eql(RTValueType.FLOAT);
          rtValue.value.should.be.eql(12.34);
          done();
        }));
    });

    it('Setting value with other types will get rejected', (done) => {
      rtObject.set(true, RTValueHelper.create(1.23456789, RTValueType.FLOAT))
        .should.be.rejectedWith('unsupported set type = boolean');
      done();
    });

    it('Getting value with other types will get rejected', (done) => {
      rtObject.get(true).should.be.rejectedWith('unsupported get type = boolean');
      done();
    });

    it('Should be able to invoke function without return value', (done) => {
      rtObject.send('method1IntAndNoReturn', RTValueHelper.create(11, RTValueType.INT32))
        .then(() => {
          done();
        });
    });

    it('Should be able to invoke function without return value', (done) => {
      rtObject.send(
        'method2FunctionAndNoReturn', RTValueHelper.create((rtValueList) => {
          logger.debug(`function invoke by remote, args count =  + ${rtValueList.length}`);
          rtValueList.forEach((rtValue) => {
            logger.debug(`value=${rtValue.value}, type=${helper.getTypeStringByType(rtValue.type)}`);
          });
          logger.debug('function invoke by remote done');
          return Promise.resolve(true);
        }, RTValueType.FUNCTION),
        RTValueHelper.create(10, RTValueType.INT32),
      )
        .then(() => {
          done();
        });
    });

    it('Should be able to invoke function with return value', (done) => {
      rtObject.sendReturns(
        'twoIntNumberSum',
        RTValueHelper.create(123, RTValueType.INT32),
        RTValueHelper.create(12, RTValueType.INT32),
      )
        .then((sum) => {
          sum.value.should.be.eql(135);
          done();
        });
    });

    it('Should be able to set and return object', (done) => {
      const testObj = {
        hello: () => {
          logger.debug('hello from test obj');
        },
      };
      const rtOldObj = RTValueHelper.create(testObj, RTValueType.OBJECT);
      rtObject.set('objvar', rtOldObj).then(() => rtObject.get('objvar').then((rtValue) => {
        const oldObjId = rtOldObj[RTConst.VALUE][RTConst.OBJECT_ID_KEY];
        const newObjId = rtValue[RTConst.VALUE][RTConst.OBJECT_ID_KEY];
        oldObjId.should.be.eql(newObjId);
        done();
      }));
    });
  });
});

/**
 * floating point values can be off by a little bit, so they may not report as exactly equal.
 * so i need use eps to check equal
 */
function checkEqualsFloat(v1, v2) {
  const eps = 0.001;
  return Math.abs(v1 - v2) < eps;
}

/**
 * double values can be off by a little bit, so they may not report as exactly equal.
 */
function checkEqualsDouble(v1, v2) {
  const eps = 0.0001;
  return Math.abs(v1 - v2) < eps;
}

/**
 * do basic test example
 * @param obj the remote object
 * @param type the rtValue type
 * @param value the value
 * @param propertyName the property name
 * @return {Promise<void>} the promise with void
 */
function doBasicTest(obj, type, value, propertyName) {
  return obj.set(propertyName, RTValueHelper.create(value, type)).then(() => obj.get(propertyName).then((rtValue) => {
    let result = false;
    if (type === RTValueType.FLOAT) {
      result = checkEqualsFloat(rtValue.value, value);
    } else if (type === RTValueType.DOUBLE) {
      result = checkEqualsDouble(rtValue.value, value);
    } else if (type === RTValueType.UINT64 || type === RTValueType.INT64 || type === RTValueType.VOIDPTR) {
      result = value.toString() === rtValue.value.toString(); //
    } else {
      result = rtValue.value === value;
    }
    return result;
  })).catch((err) => {
    logger.error(err);
  });
}
